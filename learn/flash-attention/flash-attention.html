<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flash Attention — Visualization</title>
  <style>
    :root {
      --bg: #0f1117;
      --surface: #1a1d27;
      --surface2: #242836;
      --border: #2e3345;
      --text: #e2e4eb;
      --text-muted: #8b8fa3;
      --accent: #6c8cff;
      --accent-glow: rgba(108, 140, 255, 0.15);
      --green: #4ade80;
      --orange: #fb923c;
      --red: #f87171;
      --purple: #a78bfa;
      --cyan: #22d3ee;
      --yellow: #f7e4a3;
      --indigo: #9aa8ff;
      --font-mono: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      overflow-x: hidden;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 0 12px 64px;
    }

    header {
      padding: 56px 0 32px;
      text-align: center;
      border-bottom: 1px solid var(--border);
    }

    header h1 {
      font-size: 2.4rem;
      font-weight: 700;
      letter-spacing: -0.02em;
      margin-bottom: 12px;
      background: linear-gradient(135deg, var(--accent), var(--purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    header p {
      color: var(--text-muted);
      font-size: 1.05rem;
      max-width: 720px;
      margin: 0 auto;
    }

    section {
      padding: 40px 0;
      border-bottom: 1px solid var(--border);
    }

    section:last-child {
      border-bottom: none;
    }

    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 16px;
      letter-spacing: -0.01em;
    }

    p {
      font-size: 0.95rem;
      color: var(--text);
      margin-bottom: 12px;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 24px;
    }

    .note {
      background: rgba(108, 140, 255, 0.06);
      border-left: 3px solid var(--accent);
      padding: 12px 14px;
      border-radius: 0 8px 8px 0;
      margin: 14px 0;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin: 12px 0 0;
    }

    .controls button {
      background: var(--surface2);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 10px 18px;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: var(--font-sans);
    }

    .controls button:hover {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .controls button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .play-btn {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      font-weight: 600;
    }

    .speed-active {
      background: var(--accent) !important;
      color: #fff !important;
      border-color: var(--accent) !important;
      font-weight: 600;
    }

    .status-bar {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
      font-family: var(--font-mono);
      font-size: 0.88rem;
    }

    .badge {
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--surface2);
      border: 1px solid var(--border);
    }

    .phase-indicator {
      color: var(--accent);
      font-weight: 700;
      letter-spacing: 0.03em;
    }

    .nav-link-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      background: var(--surface2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 500;
      text-decoration: none;
      transition: all 0.2s;
      font-family: var(--font-sans);
      margin-top: 16px;
    }

    .nav-link-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .nav-link-btn::after {
      content: '\2192';
      font-size: 1.1em;
    }

    canvas {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface);
      display: block;
    }

    .legend {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid var(--border);
    }

    .tally {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      font-family: var(--font-mono);
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-top: 8px;
    }

    .tally span {
      background: var(--surface2);
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 12px 0;
      font-size: 0.9rem;
    }

    .comparison-table th,
    .comparison-table td {
      padding: 10px 14px;
      border: 1px solid var(--border);
      text-align: left;
    }

    .comparison-table th {
      background: var(--surface2);
      color: var(--text);
      font-weight: 600;
    }

    .comparison-table td {
      color: var(--text-muted);
    }

    .comparison-table .highlight {
      color: var(--green);
      font-weight: 600;
    }

    @media (max-width: 768px) {
      header h1 {
        font-size: 2rem;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>Flash Attention</h1>
      <p>Data movement between HBM and on-chip SRAM during Flash Attention (Dao et al. 2022). Score and probability
        matrices never leave SRAM — every float transferred is tallied.</p>
      <a href="standard-attention.html" class="nav-link-btn">Compare with Standard Attention</a>
    </header>

    <section>
      <h2>Interactive Visualization</h2>
      <div class="card">
        <p style="color:var(--text-muted);">Every square represents one float. Unlike standard attention, the N&times;N
          score (S) and probability (P&#x0303;) matrices live and die entirely inside SRAM — they never touch HBM.</p>
        <div class="controls">
          <button id="btnPlay" class="play-btn">&#9654; Play</button>
          <button id="btnPause">&#9208; Pause</button>
          <button id="btnStep">Step &rarr;</button>
          <button id="btnBack">&larr; Back</button>
          <button id="btnReset">Reset</button>
          <span style="flex:1;"></span>
          <button id="btnFast" class="speed-active">Fast (~20s)</button>
          <button id="btnDetailed">Detailed</button>
          <span class="badge phase-indicator" id="phaseLabel">Phase 1: Initial State</span>
        </div>
        <div class="status-bar">
          <span class="badge" id="statusText">Ready</span>
        </div>
        <div style="margin-top:16px;">
          <canvas id="viz"></canvas>
        </div>
        <div id="summaryPanel" style="display:none;">
          <h3 style="font-size:1.1rem;margin:16px 0 8px;color:var(--text);">Transfer Comparison</h3>
          <table class="comparison-table">
            <tr>
              <th>Metric</th>
              <th>Standard Attention</th>
              <th>Flash Attention</th>
            </tr>
            <tr>
              <td>Peak HBM for intermediates</td>
              <td>S (128&times;128) + P (128&times;128) = 32,768 floats</td>
              <td class="highlight">No S or P in HBM</td>
            </tr>
            <tr>
              <td>Total floats transferred</td>
              <td id="stdTransfer">—</td>
              <td id="flashTransfer" class="highlight">—</td>
            </tr>
            <tr>
              <td>Savings</td>
              <td>—</td>
              <td id="savingsCell" class="highlight">—</td>
            </tr>
            <tr>
              <td>Extra FLOPs</td>
              <td>—</td>
              <td>Recomputes S, P&#x0303; per tile (trades compute for less I/O)</td>
            </tr>
          </table>
        </div>
        <div id="tally" style="display:none;"></div>
        <div class="legend">
          <div class="legend-item"><span class="swatch" style="background:#fff;"></span> X (Input)</div>
          <div class="legend-item"><span class="swatch" style="background:var(--accent);"></span> Q / Wq</div>
          <div class="legend-item"><span class="swatch" style="background:var(--green);"></span> K / Wk</div>
          <div class="legend-item"><span class="swatch" style="background:var(--red);"></span> V / Wv</div>
          <div class="legend-item"><span class="swatch" style="background:var(--yellow);"></span> S tile (SRAM only)
          </div>
          <div class="legend-item"><span class="swatch" style="background:var(--indigo);"></span> P&#x0303; tile (SRAM
            only)</div>
          <div class="legend-item"><span class="swatch" style="background:#e2e4eb;"></span> O (output)</div>
          <div class="legend-item"><span class="swatch" style="background:var(--cyan);"></span> m (row-max stats)</div>
          <div class="legend-item"><span class="swatch" style="background:var(--orange);"></span> &#x2113; (row-sum
            stats)</div>
        </div>
        <div class="note">
          S and P&#x0303; tiles exist only inside SRAM (scratch slot) — they are never written to HBM. This eliminates
          the O(N&sup2;) memory traffic that dominates standard attention.
        </div>
        <div class="note" id="backwardNote" style="display:none;">
          <strong>Backward pass (not shown):</strong> In standard attention, S and P are stored in HBM during the
          forward pass so the backward pass can read them. Flash Attention does <strong>not</strong> store S and P —
          instead, it <strong>recomputes</strong> them from Q, K, V blocks during the backward pass. This trades
          O(N&sup2;) extra FLOPs for O(N&sup2;) less HBM storage and I/O. Since attention is memory-bound (not
          compute-bound), this trade is net faster.
        </div>
      </div>
    </section>
  </div>

  <script>
    const canvas = document.getElementById('viz');
    const ctx = canvas.getContext('2d');
    let dpr = window.devicePixelRatio || 1;

    const SEQ = 128, HS = 16, GAP = 2, BLOCK_ROWS = 16;
    const NUM_BLOCKS = SEQ / BLOCK_ROWS;
    const NUM_LANES = 4;
    const NUM_SLOTS = 6;

    let speedMode = 'fast';
    function T() {
      return speedMode === 'fast'
        ? { xfer: 50, compute: 40, pause: 12 }
        : { xfer: 600, compute: 500, pause: 150 };
    }

    const colors = {
      X: '#ffffff', Wq: '#6c8cff', Wk: '#4ade80', Wv: '#f87171',
      Q: '#6c8cff', K: '#4ade80', V: '#f87171',
      S: '#f7e4a3', P: '#9aa8ff', O: '#e2e4eb',
      m: '#22d3ee', l: '#fb923c'
    };

    const mathDim = {
      X: '128\u00d716', Wq: '16\u00d716', Wk: '16\u00d716', Wv: '16\u00d716',
      Q: '128\u00d716', K: '128\u00d716', V: '128\u00d716',
      O: '128\u00d716', m: '128\u00d71', l: '128\u00d71'
    };

    const displayId = { l: '\u2113' };

    const STANDARD_TRANSFERS = (function () {
      var br = BLOCK_ROWS, nb = NUM_BLOCKS, hs = HS;
      var p2 = 3 * (hs * hs + nb * 2 * br * hs);
      var p3 = nb * (br * hs + nb * (br * hs + br * br));
      var p4 = nb * nb * 2 * br * br;
      var p5 = nb * (nb * (br * br + br * hs) + br * hs);
      return p2 + p3 + p4 + p5;
    })();

    function makeMat(id, w, h, color, init) {
      var ss = new Uint8Array(w * h);
      if (init) ss.fill(1);
      return { id: id, w: w, h: h, color: color, squareState: ss, inHBM: init };
    }

    function makeGhostMat(id, w, h, color) {
      var mat = makeMat(id, w, h, color, false);
      mat.inHBM = true;
      mat.squareState.fill(3);
      return mat;
    }

    var matrices;
    function initMatrices() {
      matrices = {
        X: makeMat('X', SEQ, HS, colors.X, true),
        Wq: makeMat('Wq', HS, HS, colors.Wq, true),
        Wk: makeMat('Wk', HS, HS, colors.Wk, true),
        Wv: makeMat('Wv', HS, HS, colors.Wv, true),
        Q: makeMat('Q', SEQ, HS, colors.Q, false),
        K: makeMat('K', SEQ, HS, colors.K, false),
        V: makeMat('V', SEQ, HS, colors.V, false),
        O: makeGhostMat('O', SEQ, HS, colors.O),
        m: makeGhostMat('m', SEQ, 1, colors.m),
        l: makeGhostMat('l', SEQ, 1, colors.l),
      };
    }

    var sramSlots = [null, null, null, null, null, null];
    var sramFlash = { active: false, start: 0, dur: 0 };
    var activeTransfers = [];
    var totalTransferred = 0;
    var skipAnimation = false;
    var runGen = 0;
    var tallyHBM = 0, tallySRAM = 0;

    var sectionLabels = [
      'Initial State in HBM',
      'Projection of Query, Key and Value',
      'Flash Attention Output'
    ];

    var slotNames = ['K block', 'V block', 'Q block', 'O accumulator', 'Statistics (m, \u2113)', 'Scratch (S/P\u0303)'];

    var L = {
      pos: {}, secBoxes: [], sram: {}, hbm: {}, tile: 0,
      canvasH: 0, cw: 0, laneTop: 0, laneBot: 0,
      wLabelY: 0, wDashTop: 0, sramSlotAreas: [], laneXs: [],
      ghostS: null, ghostP: null
    };

    function gridPx(n) { return n * L.tile + (n - 1) * GAP; }

    function hexRgba(hex, a) {
      var n = parseInt(hex.replace('#', ''), 16);
      return 'rgba(' + ((n >> 16) & 255) + ',' + ((n >> 8) & 255) + ',' + (n & 255) + ',' + a + ')';
    }

    function darkenHex(hex, f) {
      var n = parseInt(hex.replace('#', ''), 16);
      return 'rgb(' + Math.floor(((n >> 16) & 255) * f) + ',' + Math.floor(((n >> 8) & 255) * f) + ',' + Math.floor((n & 255) * f) + ')';
    }

    function computeLayout() {
      var cw = canvas.clientWidth || 1000;
      L.cw = cw;

      var hbmMargin = 8, hbmPad = 12, secPad = 8;
      var avail = cw - 2 * hbmMargin - 2 * hbmPad - 2 * secPad;
      L.tile = Math.max(3, (avail - (SEQ - 1) * GAP) / SEQ);

      var sramW = Math.min(cw - 16, cw * 0.92);
      var sramH = 320;
      L.sram = { x: (cw - sramW) / 2, y: 40, w: sramW, h: sramH };

      var slotPad = 10, slotLabelH = 16;
      var slotCols = 3, slotRowCount = 2;
      var slotW = (sramW - (slotCols + 1) * slotPad) / slotCols;
      var slotH = (sramH - slotLabelH - (slotRowCount + 1) * slotPad) / slotRowCount;
      L.sramSlotAreas = [];
      for (var row = 0; row < slotRowCount; row++) {
        for (var col = 0; col < slotCols; col++) {
          var idx = row * slotCols + col;
          L.sramSlotAreas[idx] = {
            x: L.sram.x + slotPad + col * (slotW + slotPad),
            y: L.sram.y + slotPad + slotLabelH + row * (slotH + slotPad),
            w: slotW, h: slotH
          };
        }
      }

      L.laneTop = L.sram.y + sramH;
      L.laneBot = L.laneTop + 60;
      L.laneXs = [];
      for (var i = 0; i < NUM_LANES; i++) {
        L.laneXs[i] = L.sram.x + (sramW / 5) * (i + 1);
      }

      var hbmX = hbmMargin;
      var hbmY = L.laneBot;
      var hbmW = cw - 2 * hbmMargin;
      L.hbm = { x: hbmX, y: hbmY, w: hbmW, h: 0 };

      var sx = hbmX + hbmPad + secPad;
      var y = hbmY + hbmPad;
      var secLblH = 20, matLblH = 16, matGap = 10, secPadBot = 10, secSpace = 8;
      var g16 = gridPx(HS);
      var g128 = gridPx(SEQ);
      var w16 = gridPx(HS);
      var g1 = gridPx(1);

      L.secBoxes = [];

      // Section 0: Initial State
      var s0 = y;
      y += secLblH;
      L.pos.X = { x: sx, y: y + matLblH };
      y += matLblH + g16 + matGap;

      var wLblH = 14, dashPad = 5, wGap = 12;
      var wBoxW = w16 + 2 * dashPad;
      var wStride = wBoxW + wGap;
      L.wLabelY = y;
      y += wLblH;
      L.wDashTop = y;
      y += dashPad + matLblH;
      L.pos.Wq = { x: sx + dashPad, y: y };
      L.pos.Wk = { x: sx + dashPad + wStride, y: y };
      L.pos.Wv = { x: sx + dashPad + 2 * wStride, y: y };
      L.wBoxW = wBoxW;
      L.wStride = wStride;
      L.wBoxH = dashPad + matLblH + g16 + dashPad;
      y += g16 + dashPad + secPadBot;
      L.secBoxes[0] = { x: hbmX + hbmPad, y: s0, w: hbmW - 2 * hbmPad, h: y - s0 };
      y += secSpace;

      // Section 1: Projection
      var s1 = y;
      y += secLblH;
      L.pos.Q = { x: sx, y: y + matLblH };
      y += matLblH + g16 + matGap;
      L.pos.K = { x: sx, y: y + matLblH };
      y += matLblH + g16 + matGap;
      L.pos.V = { x: sx, y: y + matLblH };
      y += matLblH + g16 + secPadBot;
      L.secBoxes[1] = { x: hbmX + hbmPad, y: s1, w: hbmW - 2 * hbmPad, h: y - s1 };
      y += secSpace;

      // Section 2: Flash Attention Output
      var s2 = y;
      y += secLblH;
      L.pos.O = { x: sx, y: y + matLblH };
      y += matLblH + g16 + matGap;
      L.pos.m = { x: sx, y: y + matLblH };
      y += matLblH + g1 + matGap;
      L.pos.l = { x: sx, y: y + matLblH };
      y += matLblH + g1 + secPadBot;
      L.secBoxes[2] = { x: hbmX + hbmPad, y: s2, w: hbmW - 2 * hbmPad, h: y - s2 };
      y += secSpace;

      // Ghost outlines for S and P (not materialized)
      var ghostLblH = 16;
      L.ghostS = { x: sx, y: y + ghostLblH, w: g128, h: g128 };
      y += ghostLblH + g128 + matGap;
      L.ghostP = { x: sx, y: y + ghostLblH, w: g128, h: g128 };
      y += ghostLblH + g128 + 10;

      L.hbm.h = y - hbmY + hbmPad;
      L.canvasH = hbmY + L.hbm.h + 16;
    }

    function resizeCanvas() {
      computeLayout();
      var dw = canvas.clientWidth;
      var dh = L.canvasH;
      canvas.style.height = dh + 'px';
      canvas.width = dw * dpr;
      canvas.height = dh * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);

    function drawBackground() {
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
    }

    function drawChrome() {
      var g = ctx;
      g.save();

      // SRAM box
      var s = L.sram;
      g.fillStyle = 'rgba(255,255,255,0.03)';
      g.strokeStyle = 'rgba(255,255,255,0.18)';
      g.lineWidth = 1.5;
      g.fillRect(s.x, s.y, s.w, s.h);
      g.strokeRect(s.x, s.y, s.w, s.h);
      g.fillStyle = '#e2e4eb';
      g.font = '12px Inter, system-ui, sans-serif';
      g.fillText('SRAM (on-chip) \u2014 6 slots', s.x + 8, s.y + 14);

      // SRAM slot outlines and labels
      g.font = '9px Inter, system-ui, sans-serif';
      g.fillStyle = '#555a6e';
      for (var i = 0; i < NUM_SLOTS; i++) {
        var sa = L.sramSlotAreas[i];
        if (!sramSlots[i]) {
          g.fillStyle = '#555a6e';
          g.fillText(slotNames[i], sa.x + 2, sa.y + sa.h / 2 + 3);
        }
        g.strokeStyle = 'rgba(255,255,255,0.05)';
        g.lineWidth = 0.5;
        g.strokeRect(sa.x, sa.y, sa.w, sa.h);
      }

      // Memory controller lanes
      for (var i = 0; i < NUM_LANES; i++) {
        var lx = L.laneXs[i];
        g.strokeStyle = 'rgba(108,140,255,0.25)';
        g.setLineDash([4, 6]);
        g.lineWidth = 1;
        g.beginPath();
        g.moveTo(lx, L.laneTop);
        g.lineTo(lx, L.laneBot);
        g.stroke();
        g.setLineDash([]);
      }

      // HBM box
      var h = L.hbm;
      g.fillStyle = 'rgba(255,255,255,0.015)';
      g.fillRect(h.x, h.y, h.w, h.h);
      g.strokeStyle = 'rgba(255,255,255,0.18)';
      g.lineWidth = 1.5;
      g.strokeRect(h.x, h.y, h.w, h.h);
      g.fillStyle = '#e2e4eb';
      g.font = '13px Inter, system-ui, sans-serif';
      g.fillText('HBM (GPU DRAM)', h.x + 10, h.y + 16);

      // Section boxes
      g.font = '12px Inter, system-ui, sans-serif';
      for (var i = 0; i < L.secBoxes.length; i++) {
        var sb = L.secBoxes[i];
        g.setLineDash([6, 6]);
        g.strokeStyle = 'rgba(255,255,255,0.14)';
        g.lineWidth = 1;
        g.strokeRect(sb.x, sb.y, sb.w, sb.h);
        g.setLineDash([]);
        g.fillStyle = '#8b8fa3';
        g.fillText(sectionLabels[i], sb.x + 6, sb.y + 14);
      }

      // Weight boxes (same as standard attention)
      var wLabels = ['weights for Query', 'weights for Key', 'weights for Value'];
      var wIds = ['Wq', 'Wk', 'Wv'];
      g.font = '10px Inter, system-ui, sans-serif';
      for (var i = 0; i < 3; i++) {
        var bx = L.pos[wIds[i]].x - 5;
        var by = L.wDashTop;
        g.fillStyle = '#8b8fa3';
        g.fillText(wLabels[i], bx, L.wLabelY + 11);
        g.setLineDash([4, 4]);
        g.strokeStyle = 'rgba(255,255,255,0.12)';
        g.lineWidth = 1;
        g.strokeRect(bx, by, L.wBoxW, L.wBoxH);
        g.setLineDash([]);
      }

      // Ghost outlines for S and P (NOT materialized)
      if (L.ghostS && L.ghostP) {
        g.setLineDash([8, 8]);
        g.lineWidth = 1;

        g.strokeStyle = 'rgba(247,228,163,0.12)';
        g.strokeRect(L.ghostS.x, L.ghostS.y, L.ghostS.w, L.ghostS.h);
        g.fillStyle = 'rgba(247,228,163,0.18)';
        g.font = '12px Inter, system-ui, sans-serif';
        g.fillText('S (128\u00d7128) \u2014 NOT materialized', L.ghostS.x, L.ghostS.y - 4);

        g.strokeStyle = 'rgba(154,168,255,0.12)';
        g.strokeRect(L.ghostP.x, L.ghostP.y, L.ghostP.w, L.ghostP.h);
        g.fillStyle = 'rgba(154,168,255,0.18)';
        g.fillText('P (128\u00d7128) \u2014 NOT materialized', L.ghostP.x, L.ghostP.y - 4);

        g.setLineDash([]);
      }

      g.restore();
    }

    function drawMatrix(mat) {
      if (!mat.inHBM) return;
      var pos = L.pos[mat.id];
      if (!pos) return;

      var g = ctx;
      g.save();
      var step = L.tile + GAP;
      var gw = gridPx(mat.w);
      var gh = gridPx(mat.h);

      g.fillStyle = darkenHex(mat.color, 0.15);
      g.fillRect(pos.x - 0.5, pos.y - 0.5, gw + 1, gh + 1);

      for (var r = 0; r < mat.h; r++) {
        for (var c = 0; c < mat.w; c++) {
          var idx = r * mat.w + c;
          var state = mat.squareState[idx];
          if (state === 0) continue;

          var tx = pos.x + c * step;
          var ty = pos.y + r * step;
          var alpha;
          if (state === 3) {
            alpha = 0.08;
          } else {
            alpha = 0.85;
            if (state === 2) alpha *= 0.3;
          }

          g.fillStyle = hexRgba(mat.color, alpha);
          g.fillRect(tx, ty, L.tile, L.tile);
        }
      }

      var label = displayId[mat.id] || mat.id;
      g.fillStyle = '#cfd2dd';
      g.font = '11px Inter, system-ui, sans-serif';
      g.fillText(label + ' ' + mathDim[mat.id], pos.x, pos.y - 3);
      g.restore();
    }

    function drawSRAMContents() {
      var g = ctx;
      for (var si = 0; si < NUM_SLOTS; si++) {
        var content = sramSlots[si];
        if (!content) continue;
        var area = L.sramSlotAreas[si];

        var maxStepW = (area.w - 2) / content.w;
        var maxStepH = (area.h - 14) / content.h;
        var maxStep = Math.min(maxStepW, maxStepH);
        var sg = maxStep >= 4 ? 1 : (maxStep >= 2 ? 0.5 : 0);
        var st = Math.max(0.6, Math.min(maxStep - sg, 6));
        var step = st + sg;
        var gw = content.w * step - sg;
        var gh = content.h * step - sg;
        var ox = area.x + (area.w - gw) / 2;
        var oy = area.y + 14 + (area.h - 14 - gh) / 2;

        g.save();
        g.fillStyle = '#cfd2dd';
        g.font = 'bold 9px Inter, system-ui, sans-serif';
        g.fillText(content.id + ' (' + content.w + '\u00d7' + content.h + ')', area.x + 2, area.y + 10);

        for (var r = 0; r < content.h; r++) {
          for (var c = 0; c < content.w; c++) {
            if (!content.tiles[r * content.w + c]) continue;
            var tileColor = content.colorPerCol
              ? content.colorPerCol[c % content.colorPerCol.length]
              : content.color;
            g.fillStyle = hexRgba(tileColor, 0.85);
            g.fillRect(ox + c * step, oy + r * step, st, st);
          }
        }
        g.restore();
      }
    }

    function drawSRAMFlashEffect() {
      if (!sramFlash.active) return;
      var elapsed = performance.now() - sramFlash.start;
      var dur = sramFlash.dur;
      var t = elapsed / dur;
      if (t >= 1) return;

      var alpha = 0;
      if (t < 0.35) alpha = Math.sin(t / 0.35 * Math.PI) * 0.7;
      else if (t >= 0.5 && t < 0.85) alpha = Math.sin((t - 0.5) / 0.35 * Math.PI) * 0.7;

      if (alpha > 0.01) {
        var g = ctx;
        g.save();
        g.strokeStyle = 'rgba(108,140,255,' + alpha + ')';
        g.lineWidth = 3;
        g.shadowColor = 'rgba(108,140,255,' + alpha + ')';
        g.shadowBlur = 15;
        var s = L.sram;
        g.strokeRect(s.x - 1, s.y - 1, s.w + 2, s.h + 2);
        g.restore();
      }
    }

    function drawLaneTraffic() {
      var g = ctx;
      var now = performance.now();
      for (var ti = 0; ti < activeTransfers.length; ti++) {
        var tr = activeTransfers[ti];
        if (tr.done || tr.inTransit <= 0) continue;

        var perLane = Math.ceil(tr.inTransit / NUM_LANES);
        var tSize = Math.max(2, Math.min(L.tile * 0.7, 5));
        var tGap = tSize * 0.6;
        var step = tSize + tGap;
        var laneLen = L.laneBot - L.laneTop;

        for (var lane = 0; lane < NUM_LANES; lane++) {
          var lx = L.laneXs[lane];
          var maxVis = Math.min(perLane, Math.floor(laneLen / step));
          var speed = tr.direction === 'toSRAM' ? -0.15 : 0.15;
          var offset = ((now * speed) % step + step) % step;

          for (var t = 0; t < maxVis; t++) {
            var y;
            if (tr.direction === 'toSRAM') {
              y = L.laneBot - step - t * step - offset;
            } else {
              y = L.laneTop + t * step + offset;
            }
            if (y < L.laneTop || y + tSize > L.laneBot) continue;
            g.fillStyle = hexRgba(tr.color, 0.9);
            g.fillRect(lx - tSize / 2, y, tSize, tSize);
          }
        }
      }
    }

    function updateTransfers() {
      var now = performance.now();
      activeTransfers = activeTransfers.filter(function (tr) {
        if (tr.done) return false;
        var p = Math.min(1, (now - tr.startTime) / tr.duration);

        if (tr.custom) {
          tr.inTransit = p < 0.85 ? Math.ceil(tr.totalSquares * (1 - p)) : 0;
          return true;
        }

        var n = tr.totalSquares;

        if (tr.direction === 'toSRAM') {
          var sent = Math.floor(Math.min(p / 0.85, 1) * n);
          var mat = matrices[tr.srcMat];
          for (var i = 0; i < n; i++) {
            var c = tr.srcCol + (i % tr.bw);
            var r = tr.srcRow + Math.floor(i / tr.bw);
            var idx = r * mat.w + c;
            if (idx < mat.squareState.length) {
              mat.squareState[idx] = (i < sent) ? 2 : 1;
            }
          }
          var arrived = Math.floor(Math.max(0, (p - 0.15) / 0.85) * n);
          var slot = sramSlots[tr.slotIdx];
          if (slot) {
            for (var i = 0; i < n; i++) {
              slot.tiles[i] = (i < arrived) ? 1 : 0;
            }
          }
          tr.inTransit = Math.max(0, sent - arrived);
        } else {
          var departed = Math.floor(Math.min(p / 0.85, 1) * n);
          var slot = sramSlots[tr.slotIdx];
          if (slot) {
            for (var i = 0; i < n; i++) {
              slot.tiles[i] = (i >= departed) ? 1 : 0;
            }
          }
          var arrived = Math.floor(Math.max(0, (p - 0.15) / 0.85) * n);
          var mat = matrices[tr.dstMat];
          for (var i = 0; i < arrived && i < n; i++) {
            var c = tr.dstCol + (i % tr.bw);
            var r = tr.dstRow + Math.floor(i / tr.bw);
            var idx = r * mat.w + c;
            if (idx < mat.squareState.length) {
              mat.squareState[idx] = 1;
            }
          }
          tr.inTransit = Math.max(0, departed - arrived);
        }
        return true;
      });
    }

    function waitMs(ms) {
      if (skipAnimation) return Promise.resolve();
      var gen = runGen;
      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          if (runGen !== gen) reject(new Error('cancelled'));
          else resolve();
        }, ms);
      });
    }

    async function transferToSRAM(srcMat, col0, row0, bw, bh, slotIdx) {
      var n = bw * bh;
      sramSlots[slotIdx] = {
        id: srcMat, color: matrices[srcMat].color,
        w: bw, h: bh, tiles: new Uint8Array(n)
      };

      if (skipAnimation) {
        sramSlots[slotIdx].tiles.fill(1);
        totalTransferred += n;
        markTallyDirty();
        return;
      }

      var t = T();
      var tr = {
        direction: 'toSRAM',
        srcMat: srcMat, srcCol: col0, srcRow: row0,
        bw: bw, bh: bh, slotIdx: slotIdx,
        color: matrices[srcMat].color,
        startTime: performance.now(),
        duration: t.xfer,
        totalSquares: n,
        inTransit: 0,
        done: false
      };
      activeTransfers.push(tr);

      await waitMs(t.xfer);

      tr.done = true;
      var mat = matrices[srcMat];
      for (var i = 0; i < n; i++) {
        var c = col0 + (i % bw);
        var r = row0 + Math.floor(i / bw);
        var idx = r * mat.w + c;
        if (idx < mat.squareState.length) mat.squareState[idx] = 1;
      }
      var slot = sramSlots[slotIdx];
      if (slot) slot.tiles.fill(1);

      totalTransferred += n;
      markTallyDirty();
    }

    async function transferToHBM(dstMat, col0, row0, bw, bh, slotIdx) {
      var n = bw * bh;
      matrices[dstMat].inHBM = true;

      if (skipAnimation) {
        var mat = matrices[dstMat];
        for (var i = 0; i < n; i++) {
          var c = col0 + (i % bw);
          var r = row0 + Math.floor(i / bw);
          var idx = r * mat.w + c;
          if (idx < mat.squareState.length) mat.squareState[idx] = 1;
        }
        sramSlots[slotIdx] = null;
        totalTransferred += n;
        markTallyDirty();
        return;
      }

      var t = T();
      var tr = {
        direction: 'toHBM',
        dstMat: dstMat, dstCol: col0, dstRow: row0,
        bw: bw, bh: bh, slotIdx: slotIdx,
        color: matrices[dstMat].color,
        startTime: performance.now(),
        duration: t.xfer,
        totalSquares: n,
        inTransit: 0,
        done: false
      };
      activeTransfers.push(tr);

      await waitMs(t.xfer);

      tr.done = true;
      var mat = matrices[dstMat];
      for (var i = 0; i < n; i++) {
        var c = col0 + (i % bw);
        var r = row0 + Math.floor(i / bw);
        var idx = r * mat.w + c;
        if (idx < mat.squareState.length) mat.squareState[idx] = 1;
      }
      sramSlots[slotIdx] = null;

      totalTransferred += n;
      markTallyDirty();
    }

    async function loadStatsToSRAM(blockIdx) {
      var col0 = blockIdx * BLOCK_ROWS;
      var nTotal = 2 * BLOCK_ROWS;

      sramSlots[4] = {
        id: 'm,\u2113', color: colors.m,
        colorPerCol: [colors.m, colors.l],
        w: 2, h: BLOCK_ROWS,
        tiles: new Uint8Array(nTotal)
      };

      if (skipAnimation) {
        sramSlots[4].tiles.fill(1);
        for (var c = col0; c < col0 + BLOCK_ROWS; c++) {
          matrices.m.squareState[c] = 1;
          matrices.l.squareState[c] = 1;
        }
        totalTransferred += nTotal;
        markTallyDirty();
        return;
      }

      for (var c = col0; c < col0 + BLOCK_ROWS; c++) {
        if (matrices.m.squareState[c] > 0) matrices.m.squareState[c] = 2;
        if (matrices.l.squareState[c] > 0) matrices.l.squareState[c] = 2;
      }

      var t = T();
      var tr = {
        direction: 'toSRAM',
        color: colors.m,
        startTime: performance.now(),
        duration: t.xfer,
        totalSquares: nTotal,
        inTransit: nTotal,
        done: false,
        custom: true
      };
      activeTransfers.push(tr);
      await waitMs(t.xfer);
      tr.done = true;

      sramSlots[4].tiles.fill(1);
      for (var c = col0; c < col0 + BLOCK_ROWS; c++) {
        matrices.m.squareState[c] = 1;
        matrices.l.squareState[c] = 1;
      }
      totalTransferred += nTotal;
      markTallyDirty();
    }

    async function writeStatsToHBM(blockIdx) {
      var col0 = blockIdx * BLOCK_ROWS;
      var nTotal = 2 * BLOCK_ROWS;

      if (skipAnimation) {
        for (var c = col0; c < col0 + BLOCK_ROWS; c++) {
          matrices.m.squareState[c] = 1;
          matrices.l.squareState[c] = 1;
        }
        sramSlots[4] = null;
        totalTransferred += nTotal;
        markTallyDirty();
        return;
      }

      var t = T();
      var tr = {
        direction: 'toHBM',
        color: colors.m,
        startTime: performance.now(),
        duration: t.xfer,
        totalSquares: nTotal,
        inTransit: nTotal,
        done: false,
        custom: true
      };
      activeTransfers.push(tr);
      await waitMs(t.xfer);
      tr.done = true;

      for (var c = col0; c < col0 + BLOCK_ROWS; c++) {
        matrices.m.squareState[c] = 1;
        matrices.l.squareState[c] = 1;
      }
      sramSlots[4] = null;
      totalTransferred += nTotal;
      markTallyDirty();
    }

    function fillSRAMSlot(slotIdx, label, color, w, h) {
      sramSlots[slotIdx] = {
        id: label, color: color, w: w, h: h,
        tiles: new Uint8Array(w * h).fill(1)
      };
      markTallyDirty();
    }

    function clearSRAMSlot(slotIdx) {
      sramSlots[slotIdx] = null;
      markTallyDirty();
    }

    async function computeFlash(msg) {
      setStatus(msg);
      if (skipAnimation) return;
      var t = T();
      sramFlash = { active: true, start: performance.now(), dur: t.compute };
      await waitMs(t.compute);
      sramFlash.active = false;
    }

    function updateTally() {
      var hbm = 0, sram = 0;
      for (var key in matrices) {
        var mat = matrices[key];
        if (!mat.inHBM) continue;
        for (var i = 0; i < mat.squareState.length; i++) {
          if (mat.squareState[i] >= 1) hbm++;
        }
      }
      for (var si = 0; si < sramSlots.length; si++) {
        var sl = sramSlots[si];
        if (!sl) continue;
        for (var i = 0; i < sl.tiles.length; i++) {
          if (sl.tiles[i]) sram++;
        }
      }
      tallyHBM = hbm;
      tallySRAM = sram;
    }

    function drawTally() {
      var g = ctx;
      g.save();
      g.font = 'bold 14px "SF Mono","Fira Code",Consolas,monospace';

      var s = L.sram;
      g.textAlign = 'left';
      g.fillStyle = '#22d3ee';
      g.fillText('SRAM  ' + tallySRAM.toLocaleString() + ' squares', s.x, s.y - 10);

      g.textAlign = 'right';
      g.fillStyle = '#fb923c';
      g.fillText('Transferred: ' + totalTransferred.toLocaleString(), s.x + s.w, s.y - 10);

      var h = L.hbm;
      g.textAlign = 'right';
      g.fillStyle = '#4ade80';
      g.fillText('HBM  ' + tallyHBM.toLocaleString() + ' squares', h.x + h.w - 8, h.y + 15);

      g.restore();
    }

    // --- Phases ---

    var phases = [
      { label: 'Initial State', action: phaseInitial },
      { label: 'Projection of Q, K, V', action: phaseProjection },
      { label: 'Flash Attention Forward Pass', action: phaseFlashForward }
    ];

    async function phaseInitial() {
      setStatus('Initial matrices in HBM: X, Wq, Wk, Wv (O, m, \u2113 as ghost placeholders)');
      markTallyDirty();
    }

    async function phaseProjection() {
      var pairs = [['Wq', 'Q'], ['Wk', 'K'], ['Wv', 'V']];
      for (var pi = 0; pi < pairs.length; pi++) {
        var wId = pairs[pi][0], outId = pairs[pi][1];

        setStatus('Loading ' + wId + ' to SRAM');
        await transferToSRAM(wId, 0, 0, HS, HS, 1);

        for (var b = 0; b < NUM_BLOCKS; b++) {
          var col0 = b * BLOCK_ROWS;

          setStatus('Loading X block ' + (b + 1) + '/' + NUM_BLOCKS + ' to SRAM');
          await transferToSRAM('X', col0, 0, BLOCK_ROWS, HS, 0);

          await computeFlash('Computing ' + outId + '[' + col0 + ':' + (col0 + BLOCK_ROWS) + '] = X_block \u00b7 ' + wId);

          fillSRAMSlot(2, outId + '_blk', colors[outId], BLOCK_ROWS, HS);
          await waitMs(T().pause);

          setStatus('Writing ' + outId + ' block ' + (b + 1) + '/' + NUM_BLOCKS + ' to HBM');
          await transferToHBM(outId, col0, 0, BLOCK_ROWS, HS, 2);

          clearSRAMSlot(0);
          await waitMs(T().pause);
        }

        clearSRAMSlot(1);
      }
    }

    async function phaseFlashForward() {
      var Tc = NUM_BLOCKS, Tr = NUM_BLOCKS;

      for (var j = 0; j < Tc; j++) {
        var kCol = j * BLOCK_ROWS;

        setStatus('Outer loop j=' + (j + 1) + '/' + Tc + ': Loading K block');
        await transferToSRAM('K', kCol, 0, BLOCK_ROWS, HS, 0);

        setStatus('Outer loop j=' + (j + 1) + '/' + Tc + ': Loading V block');
        await transferToSRAM('V', kCol, 0, BLOCK_ROWS, HS, 1);

        for (var i = 0; i < Tr; i++) {
          var qCol = i * BLOCK_ROWS;

          setStatus('Inner loop i=' + (i + 1) + '/' + Tr + ': Loading Q block');
          await transferToSRAM('Q', qCol, 0, BLOCK_ROWS, HS, 2);

          setStatus('Inner loop i=' + (i + 1) + '/' + Tr + ': Loading O accumulator');
          await transferToSRAM('O', qCol, 0, BLOCK_ROWS, HS, 3);

          setStatus('Inner loop i=' + (i + 1) + '/' + Tr + ': Loading m,\u2113 statistics');
          await loadStatsToSRAM(i);

          // Compute S_ij = Q_i * K_j^T → scratch slot 5 (yellow)
          fillSRAMSlot(5, 'S_ij', colors.S, BLOCK_ROWS, BLOCK_ROWS);
          await computeFlash('S_ij = Q_i \u00b7 K_j\u1d40 / \u221ad  [SRAM only]');

          // Transform S to P~ (color change in slot 5)
          if (sramSlots[5]) {
            sramSlots[5].id = 'P\u0303_ij';
            sramSlots[5].color = colors.P;
          }
          await computeFlash('Online softmax: update m, \u2113, rescale O');

          // O accumulation
          await computeFlash('O_i += rescaled P\u0303_ij \u00b7 V_j');

          // Clear scratch (S/P~ lived and died in SRAM)
          clearSRAMSlot(5);

          // Write O back to HBM
          setStatus('Writing O block ' + (i + 1) + '/' + Tr + ' to HBM');
          await transferToHBM('O', qCol, 0, BLOCK_ROWS, HS, 3);

          // Write stats back to HBM
          setStatus('Writing m,\u2113 statistics to HBM');
          await writeStatsToHBM(i);

          // Clear Q slot
          clearSRAMSlot(2);
          await waitMs(T().pause);
        }

        // Clear K, V for next outer iteration
        clearSRAMSlot(0);
        clearSRAMSlot(1);
      }

      setStatus('Done. Flash Attention completed.');

      // Show comparison panel
      document.getElementById('stdTransfer').textContent = STANDARD_TRANSFERS.toLocaleString();
      document.getElementById('flashTransfer').textContent = totalTransferred.toLocaleString();
      var savings = STANDARD_TRANSFERS - totalTransferred;
      var pct = ((savings / STANDARD_TRANSFERS) * 100).toFixed(1);
      document.getElementById('savingsCell').textContent = savings.toLocaleString() + ' fewer (' + pct + '% reduction)';
      document.getElementById('summaryPanel').style.display = '';
      document.getElementById('backwardNote').style.display = '';
    }

    // --- UI State ---

    var statusText = 'Ready';
    var phaseIndex = 0;
    var playing = false;

    function setStatus(msg) {
      statusText = msg;
      document.getElementById('statusText').textContent = msg;
    }

    function setPhaseLabel() {
      var p = phases[Math.min(phaseIndex, phases.length - 1)];
      document.getElementById('phaseLabel').textContent = 'Phase ' + (phaseIndex + 1) + ': ' + p.label;
    }

    function resetState() {
      runGen++;
      initMatrices();
      sramSlots = [null, null, null, null, null, null];
      sramFlash = { active: false, start: 0, dur: 0 };
      activeTransfers = [];
      totalTransferred = 0;
      phaseIndex = 0;
      setPhaseLabel();
      setStatus('Ready');
      markTallyDirty();
      document.getElementById('summaryPanel').style.display = 'none';
      document.getElementById('backwardNote').style.display = 'none';
    }

    async function runPhase(idx) {
      if (idx < 0 || idx >= phases.length) return;
      phaseIndex = idx;
      setPhaseLabel();
      await phases[idx].action();
    }

    async function playFromCurrent() {
      playing = true;
      updateButtons();
      try {
        for (var i = phaseIndex; i < phases.length; i++) {
          if (!playing) break;
          await runPhase(i);
          if (!playing) break;
          phaseIndex = i + 1;
        }
      } catch (e) {
        if (e.message !== 'cancelled') throw e;
      }
      playing = false;
      updateButtons();
    }

    function updateButtons() {
      document.getElementById('btnPlay').disabled = playing || phaseIndex >= phases.length;
      document.getElementById('btnPause').disabled = !playing;
      document.getElementById('btnStep').disabled = playing || phaseIndex >= phases.length;
      document.getElementById('btnBack').disabled = playing || phaseIndex <= 0;
    }

    document.getElementById('btnPlay').addEventListener('click', function () {
      if (phaseIndex >= phases.length) return;
      playFromCurrent();
    });

    document.getElementById('btnPause').addEventListener('click', function () {
      playing = false;
      setStatus('Paused');
      updateButtons();
    });

    document.getElementById('btnStep').addEventListener('click', async function () {
      if (phaseIndex >= phases.length) return;
      playing = true;
      updateButtons();
      try {
        await runPhase(phaseIndex);
        phaseIndex++;
      } catch (e) {
        if (e.message !== 'cancelled') throw e;
      }
      playing = false;
      updateButtons();
    });

    document.getElementById('btnBack').addEventListener('click', function () {
      var target = Math.max(0, phaseIndex - 1);
      resetState();
      skipAnimation = true;
      (async function () {
        try {
          for (var i = 0; i < target; i++) {
            await runPhase(i);
            phaseIndex = i + 1;
          }
        } catch (e) {
          if (e.message !== 'cancelled') throw e;
        }
        skipAnimation = false;
        updateButtons();
      })();
    });

    document.getElementById('btnReset').addEventListener('click', function () {
      playing = false;
      resetState();
      updateButtons();
    });

    document.getElementById('btnFast').addEventListener('click', function () {
      speedMode = 'fast';
      document.getElementById('btnFast').classList.add('speed-active');
      document.getElementById('btnDetailed').classList.remove('speed-active');
    });

    document.getElementById('btnDetailed').addEventListener('click', function () {
      speedMode = 'detailed';
      document.getElementById('btnDetailed').classList.add('speed-active');
      document.getElementById('btnFast').classList.remove('speed-active');
    });

    document.addEventListener('keydown', function (e) {
      if (e.key === ' ') {
        e.preventDefault();
        if (playing) document.getElementById('btnPause').click();
        else document.getElementById('btnPlay').click();
      }
      if (e.key === 'ArrowRight') document.getElementById('btnStep').click();
      if (e.key === 'ArrowLeft') document.getElementById('btnBack').click();
    });

    // --- Render Loop ---

    var tallyDirty = true;
    function markTallyDirty() { tallyDirty = true; }

    function drawScene() {
      drawBackground();
      updateTransfers();
      if (tallyDirty || activeTransfers.length > 0) {
        updateTally();
        tallyDirty = false;
      }
      drawTally();
      drawChrome();
      for (var key in matrices) {
        drawMatrix(matrices[key]);
      }
      drawSRAMContents();
      drawLaneTraffic();
      drawSRAMFlashEffect();
      requestAnimationFrame(drawScene);
    }

    computeLayout();
    resizeCanvas();
    initMatrices();
    resetState();
    drawScene();
  </script>
</body>

</html>
